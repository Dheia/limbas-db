<?php
/*
 * Copyright notice
 * (c) 1998-2019 Limbas GmbH(support@limbas.org)
 * All rights reserved
 * This script is part of the LIMBAS project. The LIMBAS project is free software; you can redistribute it and/or modify it on 2 Ways:
 * Under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
 * Or
 * In a Propritary Software Licence http://limbas.org
 * The GNU General Public License can be found at http://www.gnu.org/copyleft/gpl.html.
 * A copy is found in the textfile GPL.txt and important notices to the license from the author is found in LICENSE.txt distributed with these scripts.
 * This script is distributed WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 * This copyright notice MUST APPEAR in all copies of the script!
 * Version 3.6
 */

/*
 * ID:
 */

############# Domain Tables ########################

#$DBA["DOMAINTABLE"] = array("tables","views","columns","key_column_usage","constraint_table_usage","triggers","pg_constraint","pg_index","pg_indexes","pg_stats","pg_settings");
#$DBA["DOMAINSCHEMA"] = array("information_schema","information_schema","information_schema","information_schema","information_schema","information_schema","pg_catalog","pg_catalog","pg_catalog","pg_catalog","pg_catalog");

# db version
function postgres_dbf_version($db){
	
	$rs = odbc_exec($db,"SELECT SETTING FROM PG_SETTINGS WHERE NAME = 'server_version_num'") or errorhandle(odbc_errormsg($db),$prepare_string,"get next sequence",$FILE,$LINE);
	return odbc_result($rs,"SETTING");
}

############# indexes ########################

/** existing indexes
 * 
 *
 * @param array $p [0]=schema, [1]=tablename, [2]=indexname, [3]=no primary, [4]=fieldname
 * @return sql string
 */
function postgres_dbq_2($p){
	
	$sql = "SELECT
	indexname,
    t.tablename,
    foo.attname AS columnname,
    foo.indisunique AS is_unique,
    idx_scan AS index_used
FROM pg_tables t
LEFT OUTER JOIN pg_class c ON t.tablename=c.relname
LEFT OUTER JOIN
    ( SELECT c.relname AS ctablename, ipg.relname AS indexname, idx_scan, indexrelname,a.attname, x.indisprimary,x.indisunique FROM pg_index x
           JOIN pg_class c ON c.oid = x.indrelid
           JOIN pg_class ipg ON ipg.oid = x.indexrelid
           JOIN pg_stat_all_indexes psai ON x.indexrelid = psai.indexrelid 
           JOIN pg_attribute AS a ON a.attrelid = x.indexrelid
)
    AS foo
    ON t.tablename = foo.ctablename
    
WHERE t.schemaname='".$p[0]."'
";

	if($p[1]){
		$sql .= " AND LOWER(t.tablename) LIKE '".lmb_strtolower($p[1])."'";
	}
	if($p[2]){
		$sql .= " AND LOWER(indexname) LIKE '".lmb_strtolower($p[2])."'";
	}
	if($p[3]){
	 	$sql .= " AND foo.indisprimary = FALSE";
	}
	if($p[4]){
	 	$sql .= " AND LOWER(foo.attname) LIKE '".lmb_strtolower($p[4])."'";
	}

	$sql .= " ORDER BY 1, 2;";
	
	return $sql;
}


/**
 * create index
 *
 * @param array $p [0]=schema, [1]=indexname, [2]=tablename, [3]=fieldname, [4]=unique
 * @return sql string
 */
function postgres_dbq_4($p){
	if($p[4]){$unique = 'UNIQUE';}
	return "CREATE $unique INDEX ".$p[1]." ON ".$p[2]."(".$p[3].")";
}

/**
 * drop index
 *
 * @param array $p [0]=schema, [1]=indexname, [2]=tablename
 * @return sql string
 */
function postgres_dbq_5($p){
	return "DROP INDEX ".$p[1];
}



############# constaints ########################

/**
 * get primary keys
 *
 * @param array $p [0]=schema, [1]=table, [2]=column
 * @return sql string
 */
function postgres_dbq_23($db,$p=null){
	
	$sql = "SELECT
	    TC.CONSTRAINT_NAME, TC.TABLE_NAME, KCU.COLUMN_NAME, 
	    CCU.TABLE_NAME AS FOREIGN_TABLE_NAME,
	    CCU.COLUMN_NAME AS FOREIGN_COLUMN_NAME,
	    CONSTRAINT_TYPE 
	FROM 
	    INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TC 
	    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU ON TC.CONSTRAINT_NAME = KCU.CONSTRAINT_NAME
	    JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS CCU ON CCU.CONSTRAINT_NAME = TC.CONSTRAINT_NAME
	WHERE CONSTRAINT_TYPE = 'PRIMARY KEY'";
	
	if($p[1]){$sql .= " AND TC.TABLE_NAME = '".postgres_dbf_4($p[1])."'";}
	if($p[2]){$sql .= " AND KCU.COLUMN_NAME = '".postgres_dbf_4($p[2])."'";}

	$rs = odbc_exec($db,$sql) or errorhandle(odbc_errormsg($db),$sqlquery,$action,__FILE__,__LINE__);
	while(odbc_fetch_row($rs)){
		$contraint["TABLE_NAME"][] = odbc_result($rs,"TABLE_NAME");
		$contraint["COLUMN_NAME"][] = odbc_result($rs,"COLUMN_NAME");
		$contraint["PK_NAME"][] = odbc_result($rs,"CONSTRAINT_NAME");
	}
	return  $contraint;
}


/**
 * get UNIQUE contraints
 *
 * @param array $p [0]=schema, [1]=table, [2]=dbname
 * @return sql string
 */
function postgres_dbq_26($db,$p=null){
	
	$sql = "SELECT
	    TC.CONSTRAINT_NAME, TC.TABLE_NAME, KCU.COLUMN_NAME, 
	    CCU.TABLE_NAME AS FOREIGN_TABLE_NAME,
	    CCU.COLUMN_NAME AS FOREIGN_COLUMN_NAME,
	    CONSTRAINT_TYPE 
	FROM 
	    INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TC 
	    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU ON TC.CONSTRAINT_NAME = KCU.CONSTRAINT_NAME
	    JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS CCU ON CCU.CONSTRAINT_NAME = TC.CONSTRAINT_NAME
	WHERE CONSTRAINT_TYPE = 'UNIQUE'";
	
	if($p[1]){$sql .= " AND TC.TABLE_NAME = '".postgres_dbf_4($p[1])."'";}
	if($p[2]){$sql .= " AND KCU.COLUMN_NAME = '".postgres_dbf_4($p[2])."'";}

	$rs = odbc_exec($db,$sql) or errorhandle(odbc_errormsg($db),$sqlquery,$action,__FILE__,__LINE__);
	while(odbc_fetch_row($rs)){
		$contraint["TABLE_NAME"][] = odbc_result($rs,"TABLE_NAME");
		$contraint["COLUMN_NAME"][] = odbc_result($rs,"COLUMN_NAME");
		$contraint["PK_NAME"][] = odbc_result($rs,"CONSTRAINT_NAME");
	}
	return  $contraint;
}

/**
 * create primary key
 *
 * @param array $p [0]=table, [1]=field
 * @return sql string
 */
function postgres_dbq_17($p){
	return "ALTER TABLE ".$p[0]." ADD PRIMARY KEY (".$p[1].")";
}

/**
 * create constraint
 *
 * @param array $p [0]=table, [1]=field
 * @return sql string
 */
function postgres_dbq_24($p){
	return "ALTER TABLE ".$p[0]." ADD CONSTRAINT ".$p[2]." UNIQUE (".$p[1].")";
}

/**
 * drop primary key
 *
 * @param array $p [0]=table
 * @return sql string
 */
function postgres_dbq_18($p){
	return "ALTER TABLE ".$p[0]." DROP CONSTRAINT ".$p[0]."_pkey ";
}

/**
 * drop contraint
 *
 * @param array $p [0]=table
 * @return sql string
 */
function postgres_dbq_25($p){
	return "ALTER TABLE ".$p[0]." DROP CONSTRAINT ".$p[2];
}

############# foreign keys ########################

/**
 * get details for foreign keys for specific table or keyname
 *
 * @param array $p [0]=schema, [1]=tablename, [2]=keyname
 * @return sql string
 */
function postgres_dbq_3($db,$p){
	
	$sql = "SELECT
	    TC.CONSTRAINT_NAME AS FKEYNAME, TC.TABLE_NAME AS TABLENAME, KCU.COLUMN_NAME AS COLUMNNAME, 
	    CCU.TABLE_NAME AS REFTABLENAME,
	    CCU.COLUMN_NAME AS REFCOLUMNNAME,
	    CONSTRAINT_TYPE 
	FROM 
	    INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TC 
	    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KCU ON TC.CONSTRAINT_NAME = KCU.CONSTRAINT_NAME
	    JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE AS CCU ON CCU.CONSTRAINT_NAME = TC.CONSTRAINT_NAME
	WHERE CONSTRAINT_TYPE = 'FOREIGN KEY'";
	
	if($p[1]){$sql .= " AND TC.TABLE_NAME = '".postgres_dbf_4($p[1])."'";}
	if($p[2]){$sql .= " AND KCU.COLUMN_NAME = '".postgres_dbf_4($p[2])."'";}

	$sql .= " ORDER BY TC.TABLE_NAME, KCU.COLUMN_NAME";
	
	return  $sql;
}


/**
 * add foreign key
 *
 * @param array $p [0]=parent-tablename, [1]=parent-fieldname, [2]=child-tablename, [3]=child-fieldname, [4]=keyname
 * @return sql string
 */
function postgres_dbq_11($p){
	$p[5] = "DELETE RESTRICT";
	
	return "ALTER TABLE ".$p[0]." 
		ADD CONSTRAINT ".$p[4]." FOREIGN KEY (".$p[1].") 
		REFERENCES ".$p[2]."(".$p[3].") 
		ON ".$p[5];
}


/**
 * drop foreign key
 *
 * @param array $p [0]=tablename, [1]=keyname
 * @return sql string
 */
function postgres_dbq_6($p){
	return " ALTER TABLE ".$p[0]." DROP CONSTRAINT ".$p[1]." CASCADE";
}


############# trigger ########################


/**
 * get information about database trigger
 *
 * @param array $p [0]=schema, [1]=triggername
 * @return array
 */
function postgres_dbf_3($db,$p){

	$sql = "SELECT TRIGGER_NAME AS TRIGGERNAME, ACTION_STATEMENT AS DEFINITION, EVENT_MANIPULATION AS EVENT, EVENT_OBJECT_TABLE AS TABLENAME
		FROM
		 	INFORMATION_SCHEMA.TRIGGERS
		WHERE TRIGGER_SCHEMA != 'pg_catalog'";
	if($p[1]){
		$sql .= " AND LOWER(TRIGGER_NAME) LIKE '".lmb_strtolower($p[1])."'";
	}
	
	$rs = odbc_exec($db,$sql);
	while(odbc_fetch_row($rs)){
		$res["triggername"][] = odbc_result($rs,"TRIGGERNAME");
		$res["definition"][] = odbc_result($rs,"DEFINITION");
		$res["event"][] = odbc_result($rs,"EVENT");
		$res["tablename"][] = odbc_result($rs,"TABLENAME");
	}
	
	return $res;
}


/**
 * drop database trigger
 *
 * @param array $p [0]=schema, [1]=triggername
 * @return sql string
 */
function postgres_dbq_10($p){
	return "DROP TRIGGER ".$p[0]." 
		ON ".$p[1];
}

/**
 * create trigger
 *
 * @param array $p [0]=schema, [1]=triggername, [2]=tablename, [3]=action, [4]=value, [5]=position
 * @return sql string
 */
function postgres_dbq_13($p){
	$sql = "CREATE TRIGGER ".$p[1]." ".$p[5]." ".$p[3]." ON ".postgres_dbf_4($p[2])." FOR EACH ROW EXECUTE PROCEDURE ".$p[4];
	return $sql;
}

/**
 * limbas specific trigger function for limbas relation schema
 *
 * @param array $p [0]=schema, [1]=triggername, [2]=tablename, [3]=action, [4]=value
 * @return sql string
 */
function postgres_dbq_14($p){
	return "lmb_vkn('".$p[1]."','".$p[2]."','".$p[3]."','".$p[4]."','".$p[5]."');";
}


/**
 * limbas specific trigger function for lastmodified
 *
 * @param array $p [0]=schema, [2]=tableid
 * @return sql string
 */
function postgres_dbq_27($p){
	return "lmb_lastmodified('".$p[1]."');";
}

############# view ########################


/**
 * get view definition
 *
 * @param array $p [1]=viewname
 * @return sql string
 */
function postgres_dbq_8($p){
	return "SELECT pg_get_viewdef('".$p[1]."', true) AS DEFINITION";
}

/**
 * existing views
 *
 * @param array $p [0]=schema, [1]=viewname
 * @return sql string
 */
function postgres_dbq_12($p){
	$qu = "SELECT view_name AS VIEWNAME, table_name AS TABLENAME 
		FROM 
			information_schema.view_table_usage 
		WHERE 
			view_schema = '".$p[0]."'";
	if($p[1]){
		$qu .= " AND lower(view_name) = '".lmb_strtolower($p[1])."'";
	}
	return $qu;
}

/**
 * create view
 *
 * @param array $p [0]=view name, [1]=definition
 * @return sql string
 */
function postgres_dbq_19($p){
	if(lmb_stripos($p[1],"CREATE VIEW") !== false){
		$qu = $p[1];
	}else{
		$qu = "CREATE OR REPLACE VIEW ".$p[0]." AS (".rtrim(trim($p[1]),";").")";
	}
	
	return $qu;
}

/**
 * drop view
 *
 * @param array $p [0]=view name
 * @return sql string
 */
function postgres_dbq_20($p){

	$qu = "DROP VIEW ".$p[0];

	return $qu;
}


/**
 * rename view
 *
 * @param array $p [0]=old tablename, [0]=new tablename
 * @return sql string
 */
function postgres_dbf_24($p){
	return "ALTER VIEW ".postgres_dbf_4($p[0])." RENAME TO ".postgres_dbf_4($p[1]);
}


/**
 * check view dependencies
 *
 * @param array $p [0]=schema, [1]=tablename, [2]=fieldname
 * @return array
 */
function postgres_dbf_25($db,$p){
    
    if($p[1]){$w = " AND source_table.relname = '".postgres_dbf_4($p[1])."'";}
    if($p[2]){$w .= " AND pg_attribute.attname = '".postgres_dbf_4($p[2])."'";}
    
    /*
     dependent_ns.nspname as dependent_schema,
     source_ns.nspname as source_schema,
     source_table.relname as source_table,
     pg_attribute.attname as column_name,
    */
    
    $qu = "SELECT DISTINCT 
    dependent_view.relname as dependent_view 
    FROM pg_depend 
    JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid 
    JOIN pg_class as dependent_view ON pg_rewrite.ev_class = dependent_view.oid 
    JOIN pg_class as source_table ON pg_depend.refobjid = source_table.oid 
    JOIN pg_attribute ON pg_depend.refobjid = pg_attribute.attrelid 
    AND pg_depend.refobjsubid = pg_attribute.attnum 
    JOIN pg_namespace dependent_ns ON dependent_ns.oid = dependent_view.relnamespace
    JOIN pg_namespace source_ns ON source_ns.oid = source_table.relnamespace
    WHERE 
    source_ns.nspname = '".$p[0]."'
    AND pg_attribute.attnum > 0 
    $w";
    
    #error_log($qu);
    
    $dep = false;
	$rs = odbc_exec($db,$qu);
	while(odbc_fetch_row($rs)){
		$dep[] = odbc_result($rs,"dependent_view");
		#$dep["table"][] = odbc_result($rs,"source_table");
		#$dep["field"][] = odbc_result($rs,"column_name");
	}
	
	return $dep;
}


############# tables ########################

/**
 * rename table
 *
 * @param array $p [0]=old tablename, [1]=new tablename
 * @return sql string
 */
function postgres_dbf_17($p){
	return "ALTER TABLE ".postgres_dbf_4($p[0])." RENAME TO ".postgres_dbf_4($p[1]);
}
	
/**
 * list of tables / views
 *
 * @param array $p [0]=schema, [1]=name, [2]=typ
 * @return sql array
 */
function postgres_dbf_20($db,$p){
    
    echo $p[1];

	$rs = odbc_tables($db,null,$p[0],postgres_dbf_4($p[1]),$p[2]);
	while(odbc_fetch_row($rs)){
		$odbc_table["table_name"][] = odbc_result($rs,"TABLE_NAME");
		$odbc_table["table_type"][] = odbc_result($rs,"TABLE_TYPE");
		$odbc_table["table_owner"][] = odbc_result($rs,"TABLE_OWNER");
	}
	
	if($odbc_table){
		return $odbc_table;
	}else{
		return false;
	}

}

############# SEQUENCE ########################

/**
 * create sequence
 *
 * @param array $p [0]=schema, [1]=name, [2]=start
 */
function postgres_dbf_21($db,$p){
	
	#first drop sequence if exists
	postgres_dbf_22($p);
	
	if($p[2]){$start = " START ".$p[2];}
	if($rs = odbc_exec($db,"CREATE SEQUENCE ".postgres_dbf_4($p[1]).$start)){
		return true;
	}else{
		return false;
	}
}

/**
 * drop sequence
 *
 * @param array $p [0]=schema, [1]=name
 */
function postgres_dbf_22($db,$p){

    #$rs1 = odbc_exec($db,"SELECT C.RELNAME FROM PG_CLASS C WHERE C.RELKIND = 'S' AND RELNAME = '".postgres_dbf_4($p[1])."'");  //TODO
    #if(odbc_result($rs1, "RELNAME")) {
        $rs = odbc_exec($db, "DROP SEQUENCE " . postgres_dbf_4($p[1]) . " CASCADE");
        if ($rs) {
            return true;
        } else {
            return false;
        }
    #}
}


############# columns ########################


/**
 * list of columns
 *
 * @param array $p [0]=schema, [1]=tablename, [2]=fieldname
 * @return sql string
 */
function postgres_dbf_5($db,$p,$mode=null){
	
	if($p[2]){
		$rs = odbc_columns($db,null,$p[0],postgres_dbf_4($p[1]),postgres_dbf_4($p[2]));
	}else{
		$rs = odbc_columns($db,null,$p[0],postgres_dbf_4($p[1]));
	}
	
	if($p[3]){return $rs;}
	
	while(odbc_fetch_row($rs)) {
		$col["tablename"][] = trim(odbc_result($rs, "TABLE_NAME"));
		$col["columnname"][] = trim(odbc_result($rs, "COLUMN_NAME"));
		$col["columnname_lower"][] = postgres_dbf_4(trim(odbc_result($rs, "COLUMN_NAME")));
		$col["datatype"][] = trim(odbc_result($rs, "TYPE_NAME"));
		$col["length"][] = trim(odbc_result($rs, "PRECISION"));
		$col["scale"][] = trim(odbc_result($rs, "SCALE"));
		$col["default"][] = trim(odbc_result($rs, "COLUMN_DEF"));
		
		#$sql = "SELECT scc.column_name as \"Field\", udt_name as \"UDT\", data_type as \"Type\", is_nullable as \"Is Nullable\",keys.key as \"Key\", column_default as \"Default\"
		
		if($mode){
			$sql = "SELECT keys.key as \"Key\"
	        FROM INFORMATION_SCHEMA.COLUMNS scc LEFT JOIN
	           (SELECT table_schema, table_name, column_name, (CASE WHEN (c.contype = 'c') THEN 'CHECK'
	               WHEN (c.contype = 'f') THEN 'FOREIGN KEY'
	               WHEN (c.contype = 'p') THEN 'PRIMARY KEY'
	               WHEN (c.contype = 'u') THEN 'UNIQUE'
	               ELSE NULL END)  as key
	           FROM information_schema.constraint_column_usage col, pg_constraint c
	           WHERE table_schema = '".$p[0]."' AND table_name = '".$p[1]."'
	               AND c.conname = col.constraint_name) as keys  ON scc.column_name = keys.column_name
	        WHERE scc.table_name = '".$p[1]."' AND scc.column_name = '".odbc_result($rs, "COLUMN_NAME")."'";
			if($rs1 = odbc_exec($db,$sql)){
				$col["mode"][] = odbc_result($rs1, "Key");
			}else{
				$col["mode"][] = "";
			}
		}
	}

	if($col){
		return $col;
	}else{
		return false;
	}
}

/**
 * modify column default
 *
 * @param array $p [0]=schema, [1]=tablename, [2]=columnname, [3]=value
 * @return sql string
 */
function postgres_dbq_9($p){
	return "ALTER TABLE ".postgres_dbf_4($p[1])." ALTER ".postgres_dbf_4($p[2])." SET DEFAULT ".$p[3];
}

/**
 * rename column 
 *
 * @param array $p [0]=schema, [1]=tablename, [2]=old columnname, [3]=new columnname
 * @return sql string
 */
function postgres_dbq_7($p){
	return "ALTER TABLE ".postgres_dbf_4($p[1])." RENAME ".postgres_dbf_4($p[2])." TO ".postgres_dbf_4($p[3]);
}

/**
 * modify column type 
 *
 * @param array $p [0]=schema, [1]=tablename, [2]=columnname, [3]=value
 * @return sql string
 */
function postgres_dbq_15($p){
	return "ALTER TABLE ".postgres_dbf_4($p[1])." ALTER ".postgres_dbf_4($p[2])." TYPE ".postgres_dbf_4($p[3]);
}

/**
 * drop column
 *
 * @param array $p [0]=tablename, [1]=columnname
 * @return sql string
 */
function postgres_dbq_22($p){
	return "ALTER TABLE ".postgres_dbf_4($p[0])." DROP ".postgres_dbf_4($p[1]);
}

############# stored procedures ########################


/**
 * limbas based lmb_vkn procedure 
 *
 * @param
 * @return sql string
 */
function postgres_dbq_16($db,$p=null){

	$sqlquery = "
CREATE OR REPLACE FUNCTION lmb_vkn() RETURNS trigger AS '
DECLARE

statement VARCHAR(200);
nid INTEGER;

BEGIN

IF TG_ARGV[2] = ''+'' THEN
     nid = new.id;
END IF;
IF TG_ARGV[2] = ''-'' THEN
    nid = old.id;
END IF;

statement = ''UPDATE '' || TG_ARGV[0] || '' SET '' || TG_ARGV[1] || '' = (SELECT COUNT(*) FROM '' || TG_RELNAME || '' WHERE id = '' || nid || '') WHERE id = '' || nid;
EXECUTE statement;


IF TG_ARGV[3] = '''' THEN
    return new;
END IF;

IF TG_ARGV[2] = ''+'' THEN
     nid = new.verkn_id;
END IF;
IF TG_ARGV[2] = ''-'' THEN
    nid = old.verkn_id;
END IF;


statement = ''UPDATE '' || TG_ARGV[3] || '' SET '' || TG_ARGV[4] || '' = (SELECT COUNT(*) FROM '' || TG_RELNAME || '' WHERE verkn_id = '' || nid || '') WHERE id = '' || nid;
EXECUTE statement;


return new;

END; '  LANGUAGE 'plpgsql';
	";

	$rs = odbc_exec($db,$sqlquery) or errorhandle(odbc_errormsg($db),$sqlquery,"create procedure lmb_vkn",__FILE__,__LINE__);
	if(!$rs){
		return false;
	}
	
	$sqlquery = "
CREATE OR REPLACE FUNCTION lmb_lastmodified() RETURNS trigger AS '
DECLARE

statement VARCHAR(200);

BEGIN

statement = ''UPDATE LMB_CONF_TABLES SET LASTMODIFIED = CURRENT_TIMESTAMP WHERE TAB_ID = '' || TG_ARGV[0];
EXECUTE statement;

return new;

END; '  LANGUAGE 'plpgsql';
	";

	$rs = odbc_exec($db,$sqlquery) or errorhandle(odbc_errormsg($db),$sqlquery,"create procedure lmb_lastmodified",__FILE__,__LINE__);
	if(!$rs){
		return false;
	}
	
	return true;
	
}

/**
 * drop limbas based lmb_vkn procedure 
 *
 * @param
 * @return bool
 */
function postgres_dbq_21($db,$p){

	$rs = odbc_exec($db, "SELECT PROSRC FROM PG_PROC WHERE PRONAME = 'lmb_vkn'"); //TODO
    if(odbc_result($rs,"PROSRC")) {
        $sqlquery = "drop function lmb_vkn()";
        $rs1 = odbc_exec($db, $sqlquery);
    }
}



?>